\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{enumitem}
\usepackage{listings}
\usepackage[T1]{fontenc}
\usepackage{geometry}

\geometry{
 a4paper,
 left=20mm,
 right=20mm,
 top=20mm,
 bottom=20mm
 }

\lstset{
    language=C,
    showstringspaces=false,
    breaklines=true
}


\title{ME 333 Quiz 5: Chapter 5 \& 6}
\author{Marshall Johnson}
\date{February 10, 2022}

\begin{document}

\maketitle

\section*{Quiz 5}

\begin{enumerate}[label=\textbf{\arabic*})]
    \item \textbf{Draw the voltage that is generated by a “bouncey” push button, and describe a method for 
    debouncing it using code in an interrupt.} \\
    \\
    \\
    \\
    \\
    \\
    \\
    \\
    \\
    \\
    \\
    \\
    \\
    \\
    \\
    A button press should last more than 10 ms, while the mechanical bouncing period of a switch should be much 
    less than that. To debounce a button, interrupt code can be configured to wait for 10 ms before executing
    desired button press code. Any press shorter than 10 ms is ignored.

    \item \textbf{What are each of the IFSx, IECx, and IPCx registers used for?} \\
    \begin{enumerate}
        \item IECx: Interrupt enable control SFR --- 1 enables interrupt; 0 disables
        \item IFSx: Interrupt flag status SFR --- 1 requests given interrupt;
        0 indicates no interrupt requested 
        \item IPCx: Interrupt priority control SFR --- contains 5-bit priority
        and subpriority values for 4 different interrupt vectors; interrupts will
        not be serviced unless CPU's current priority is less than interrupt's 
        priority
    \end{enumerate}

    \item \textbf{What is “context save and restore”, and how do you avoid using it?} \\

    Context save and restore is the copying of register data back and forth between registers and RAM. 
    This can be avoided by using the extra registers provided by the shadow register set (SRS), 
    eliminating the time needed for context save and restore.

    \item \textbf{The following methods of calculating velocity produce about the same results. What is the 
    advantage of the second method, and how could you use the .dis file to prove it?} \\

    The second uses integer math rather than floating point math --- this results in a faster computation.
    The speed advantage can be confirmed by viewing the .dis file. Counting the number of assembly statements
    for each in the corresponding assembly code would provide confirmation. The second method would have 
    fewer statements, which would likely mean it runs faster.


\end{enumerate}



\end{document}
